[TOC]

# 第六章 当 C++爱上面向对象

## 面向对象的三座基石：封装、继承与多态

面向对象的三板斧分别是封装、继承和多态，用封装将问题中的数据和对数据进行处理的函数结合在了一起，形成了一个整体的类的概念；它用继承来应对系统的扩展，在原有系统的基础上，只要简单继承，就可以完成系统的扩展，而无需重起炉灶；多态机制保证了在继承的同时，还有机会对已有行为进行重新定义，满足了不断出现的新需求的需要。

------

**面向对象目的：高内聚，低耦合:**

高内聚，低耦合通常用以判断一个软件设计的好坏。所谓的高内聚，是指一个软件模块是由**相关性很强的代码组成**，只负责某项单一任务，也就是常说的‚单一责任原则。而低耦合指的是在一个完整的系统中，**模块与模块之间，尽可能地保持相互独立**。

高内聚低耦合的系统具有更好的重用性、可维护性和扩展性，可以更高效的完成系统的开发、维护和扩展，持续地支持业务的发展。

------

## C++中的类

![image-20211128144518120](https://i.loli.net/2021/11/28/xECtShZqvjzdJiA.png)

#### 类的声明

```c++
class 类名
{
    public :
     // 公有成员，通常用来描述这类对象的相同行为

    protected:
     // 受保护部分，自己和子类访问

    private:
     // 私有成员，通常用来描述这类对象的共同属性
}; // 注意这里有个分号表示类的结束
```

说明：如果类的某些成员变量具有初始值，我们可以在类中声明这些成员变量的同时给它一个初始值，这样在运行期间，类就可以在进入构造函数之前，直接使用这个初始值完成相应成员变量的初始化。

声明一个老师的类：

```c++
// 老师
class Teacher
{
    // 成员函数
    // 描述对象的行为
    public: // 公有部分，供外界访问
    	void GiveLesson(); // 上课

    
    protected:// 受保护部分，自己和子类访问
     string m_strName='name'; // 初始化姓名
    
    private:
};
```

注意：类成员函数的具体定义可以直接在类中声明成员函数的时候同时完成。

**更多时候，我们只是将类的声明放在头文件（比如，Teacher.h 文件）中，而将成员函数的具体实现放在类的外部定义，也就是相应的源文件（比如，Teacher.cpp）中：**

在类的外部定义类的成员函数时，我们需要在源文件中引入类声明所在的头文件，并且在函数名之前还要用`::`域操作符指出这个函数所属的类。例如：

```c++
#ifndef _TEACHER_H // 定义头文件宏，防止头文件被重复引入
#define _TEACHER_H // 在稍后的 7.3.1 小节中会有详细介绍
// Teacher.h 类的声明文件
class Teacher
{
    // …
    public:
        void GiveLesson(); // 只声明，不定义
};


// Teacher.cpp 类的定义文件
#include "Teacher.h"// 引入类声明所在的头文件
// 在 Teacher 类外完成成员函数的定义
void Teacher::GiveLesson()
{
    cout<<"老师上课。"<<endl;
}
```

**知道更多：`struct `和` class`的区别：**

在语法上，`class`和`struct`非常相似，两者都可以用来声明类，而两者唯一的区别就是，在没有指定访问级别的默认情况下，用‚class‛声明的类当中的成员是私有的（private），而用struct声明的类当中的成员是公有的（public）。

------

#### 类的实例化：创建对象

创建对象：

```c++
// 定义一个 Teacher 类型的对象 MrChen，代表陈老师
Teacher MrChen;
```

用`.`操作符访问对象公有成员或公有函数：

```c++
// 调用对象所属类的成员函数，表示这位老师开始上课
MrChen.GiveLesson();
```

也可以通过**指针**访问对象成员：

```c++
// 定义一个可以指向 Teacher 类型对象的指针 pMrChen，初始化为空指针
Teacher* pMrChen = nullptr;
// 用“&”操作符取得 MrChen 对象的地址赋值给指针 pMrChen，
pMrChen = &MrChen;

// 通过指针访问对象的成员
pMrChen->GiveLesson();
```

还可以使用**“new”关键字**直接创建一个对象并返回该对象的地址，再用这个地址对指针进行赋值，同样可以创建新的对象并将指针指向这个新的对象。例如：

```c++
// 创建一个新的 Teacher 对象

// 并让 pMrChen 指针指向这个新对象

Teacher* pMrChen = new Teacher();
```

这里，“new”关键字会负责完成 Teacher 对象的创建，并返回这个对象的地址，然后再将这个返回的

对象地址赋值给 pMrChen 指针，这样就同时完成了对象的创建和指针的赋值。

> 注意：使用“new”创建的对象无法在其生命周期结束后自动销毁，所以我们**必须在对象使用完毕后，用“delete”关键字人为地销毁这个对象**，释放其占用的内存。例如：
>
> ```c++
> // 销毁指针所指向的对象
> delete pMrChen;//当对象被销毁后，原来指向这个对象的指针就成了一个指向无效地址的“野指针”
> pMrChen = nullptr; // 指向的对象销毁后，重新成为空指针
> ```

------

#### 一个对象的生与死：构造函数和析构函数

在创建对象的时候，需要进行很多初始化工作，设置某些属性的初始值；而在销毁对象的时候，需要进行一些清理工作，最重要的是把申请的资源释放掉，把打开的文件关闭掉。

为了完成对象的生与死这两件大事，C++中的类专门提供了两个特殊的函数——**构造函数**（Constructor）和**析构函数**（Destructor）。他们会在对象创建和销毁时自动调用。

##### 为类添加构造函数

+ 大多数情况下构造函数的访问级别应该是**公有**（public）的
+ 构造函数必须跟类**同名**
+ 构造函数只是完成对象的创建，并**不需要返回数据**

举个例子：

```c++
class Teacher 
{
    public:
    // 构造函数,参数表示 Teacher 类对象的名字
     Teacher(string strName) 
     {
         // 使用参数对成员变量赋值，进行初始化
         m_strName = strName;
     };
    protected:
    private:
};

// 使用参数，创建一个名为“WangGang”的对象
Teacher MrWang("WangGang");
```

除了可以使用`“=”`操作符对对象的成员变量进行赋值以完成初始化之外，还可以使用`“:”`符号在构造函数后引出初始化属性列表。

```c++
class Teacher
{
public:
 // 使用初始化属性列表的构造函数
 Teacher(string strName,int age) : m_strName(strName),m_intAge(age)
     // 初始化属性列表，使用构造函数的参数 strName 创建并初始化 m_strName
 {
	// 构造函数中无需再对 m_strName 赋值 
 }
}
```

根据初始条件的不同，类常常有多个不同参数形式的构造函数，如下:**（ 构造函数 Teacher()委托调用构造函数 Teacher(int x)）**

```c++
class Teacher
{
    public:
     	// 带参数的构造函数
        Teacher(int x) 
         { 
             // 判断参数是否合理，决定赋值与否
            if (0 < x && x <= 100) 
            	m_nAge = x; 
            else 
           	    cout<<"错误的年龄参数"<<endl; 
         }
         // 构造函数 Teacher()委托调用构造函数 Teacher(int x)
         // 这里我们错误地把出生年份当作年龄参数委托调用构造函数 Teacher(int x)，
         // 直接实现了参数合法性验证并赋值的功能
        Teacher() : Teacher(1982)
        {
        // 完成特有的创建工作
        }
}
```

------

##### 为类添加析构函数

+ 析构函数名：“~”符号+类名

举个例子：因为 Teacher 类不需要额外的清理工作，所以在这里我们没有定义任何操作，只是输出一段信息表示 Teacher 类对象的结束。

```c++
class Teacher
{
    public: // 公有的访问级别
        ~Teacher() // 不接受任何参数
        {
            // 进行清理工作
            cout<<"春蚕到死丝方尽，蜡炬成灰泪始干"<<endl;
        }; 
};
```

------

##### 拷贝构造函数

除了直接创建一个新的对象之外，有时还需要根据已经存在的某个对象创建它的一个副本：

```c++
Teacher MrYang;// 调用构造函数创建一个新对象 MrYang

Teacher MrZhu(MrYang);//用MrYang对象作为构造函数的参数创建新对象MrZhu
```



拷贝构造函数是默认生成的，某些特殊情况下，特别是类当中有指针类型的成员变量的时候，以拷贝内存方式实现的默认拷贝构造函数只能复制指针成员变量的值，而不能复制指针所指向的内容，这样，**新旧两个对象中不同的两个指针却指向了相同的内容**，这显然是不合理的，此时就要定义拷贝构造函数。

实现代码见：[定义自己的拷贝构造函数](https://github.com/Jy-stdio/CS-AI-Notes/blob/main/hello_c%2B%2B/%E7%AC%AC%E5%85%AD%E7%AB%A0/code/%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.cpp)

------

##### 操作符重载

在功能上，重载操作符等同于类的成员函数，但是用重载操作符可以让语句更加简洁。声明重载操作符的语法格式如下：

```c++
class 类名
{
    public:
         返回值类型 operator 操作符 (参数列表)
         {
         // 操作符的具体运算过程
         }
};
```

举个例子：

要想让“father + mother”得到 baby 对象，只需要定义 Father 类的“+”操作符函数（因为 father位于操作符之前，所以我们定义 father 所属的 Father 类的操作符），使其可以接受一个 Mother 类的对象作为参数，并返回一个 Baby 类的对象就可以了：

```c++
// 母亲类
class Mother
{
// 省略具体定义
};


// 孩子类
class Baby
{
    public:
        // 孩子类的构造函数
        Baby(string strName): m_strName(strName)
        {}
    private:
    	string m_strName;     // 孩子的名字
};


// 父亲类
class Father
{
    public:
        // 重载操作符“+”，返回值为 Baby 类型，参数为 Mother 类型
        Baby operator + (const Mother& mom)
        {
            // 创建一个 Baby 对象并返回，省略创建过程…
            return Baby("MiaoMiao");
     }
};   


Father father;Mother mother;     
Baby baby = father + mother;
```

------

#### 类成员的访问控制

对类成员的访问控制是通过设置成员的访问级别来实现的。按照访问范围的大小，访问级别被分为公有类型（public）、保护类型（protected）和私有类型（private）三种。

访问级别如下图所示：

![image-20211128165550700](https://i.loli.net/2021/11/28/mjeuBMnQ1JwhLIf.png)

注意：保护类型可以让其派生类也拥有其中的成员，实现对其的访问。

> 如果对象的某些成员变量因为业务逻辑的需要允许外界访问，也建议采用提供**公有接口**的方法，让外界通过公有接口来访问这些成员变量，而不是直接把这些成员变量设置为公有类型。**一般情况下，类的成员变量都应该设置为保护或私有类型。**

👍**!!私有信息并不是外界完全无法访问，可以使用在友元机制访问类的隐藏信息：**

利用“friend”关键字，可以将外界的某个函数或者类声明为类的友元函数或者友元类，两者统称为友元。

1. 友元函数

友元函数实际上是一个定义在类外部的普通函数，它不属于任何类。当使用“friend”关键字在类的定义中加以声明后，这个函数就成为类的友元函数

```c++
class 类名
{
	friend 返回值类型 外部定义的函数名(形式参数列表);
	// 类的其他声明和定义…
};
```

2. 友元类

跟友元函数相似，友元类是定义在某个类之外的另外一个独立的普通类。因为需要访问这个类的隐藏信息，所以利用“friend”关键字将其声明为这个类的友元类，赋予它访问这个类的隐藏信息的能力。

```
class 类名
{
    friend class 友元类名;
    // 类的其他声明和定义
};
```

## 用基类和派生类实现继承

我们把表示父类别的类称为基类或者父类，而把从基类继承产生的表示子类别的类称为派生类或子类，一个类可以同时继承多个类。但是多继承可能会带来成员的二义性，一般来说我们使用的是单继承。

派生类(新类)的声明方式如下：

```c++
class 派生类名 : 继承方式 基类名 1, 继承方式 基类名 2… {
 // 派生类新增加的属性和行为…
};
```



**继承方式**
