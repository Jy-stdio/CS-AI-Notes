*对已经掌握的内容例如数据类型等等的知识本文不予以记录，仅仅记录不会的或者不熟悉的知识*

[TOC]



# 第二章  与C++第一次亲密接触

## main函数

问题：为什么C++只能有一个main函数？

+ 执行程序时，执行程序的进程会首先创建主线程，主线程然后调用约定启动运行时库，由

  启动运行时库调用约定好的 main 函数，自此开始执行用户的代码。main 函数是主线程的执行入口。

+ 一个线程不可能拥有多个执行入口。而且在 C++中，全局符号(变量、函数) 只能有一个定义，main 函数作为一个全局函数，自然也就只能有一个。

## 编译器和链接器

![一个cpp文件如何变成一个exe可执行文件](https://i.loli.net/2021/11/27/2gGol6yJRIaHKit.png)

源文件HelloWorld.cpp经过**编译器(cl.exe)**的编译后，得到一个无法直接执行的目标文件HelloWorld.obj，还需要**链接器(link.exe)**将这个目标文件和 Visual C++所提供的标准库目标文件（比如，libcpmt.lib）整合成最终的可执行文件HelloWorld.exe。

## C++程序的执行过程

主函数之前的准备工作：进入主函数开始执行之前，操作系统会帮我们做很多准备工作。

> 比如，当操作系统接到执行某个程序的指令后，它首先要创建相应的进程并分配私有的进程空间；然后加载器会把可执行文件的数据段和代码段映射到进程的虚拟内存空间中；操作系统接着会初始化程序中定义的全局变量等。
>
> 做好这些准备工作，程序就可以进入主函数开始执行了。



当启动一个程序后，操作系统会创建新的进程来执行这个程序。所谓进程，就是应用程序的一个实例。

操作系统创建进程的时候，会为其分配一定的内存空间（默认堆），作为其私有的虚拟地址空间。

通常，一个应用程序的执行对应于一个进程，进程负责管理这个程序运行时的一切事物，例如资源的分配与调度等等。但是，作为程序执行的调度者，它并不负责程序的执行，具体的执行工作，则是由它所创建的线程来完成的。

每个进程都有一个主线程，如果是多线程应用程序，还可以有多个辅助线程。线程并不拥有资源（它使用的是它所属进程的资源），但是它拥有自己的执行入口、执行的顺序系列和一个执行终点。

## 标准的输入和输出对象

C++标准库中已经预先定义了 4 个最基本的输入/输出流（I/O）对象，只要引入相应的头文件\<iostream\>:

+ 输入的**cin **:用`>>`从cin提取键盘输入数据
+ 负责屏幕输出的**cout **：用`<<`向cout插入程序内的数据
+ 输出程序错误信息的**cerr**
+ 输出日志信息的 **clog**。

## 读写文件

C++标准库提供了 ifstream（input file stream） 和 ofstream（output file stream），用来读取数据和将数据写入文件。它们定义在\<fstream\>头文件中。

代码：

+ [读写文件实现](https://github.com/Jy-stdio/CS-AI-Notes/blob/main/hello_c%2B%2B/%E7%AC%AC%E4%B8%80%E7%AB%A0code/%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6.cpp)



# 第三章



## 在 Linux/UNIX 平台上用 GCC 开发 C++程序

Linux/UNIX 平台上的使用 vi 编辑源代码；使用 GCC 编译代码；使用 GDB 调试代码等等。

GCC编译命令：` g++ [编译选项] 源文件名`

## 变量命名法之匈牙利命名法

$$
变量名 ＝ 属性 + 类型 + 对象描述
$$

举个栗子：`m_unAge`的意义就是：这是某个类的成员变量（m_），它的数据类型是 unsigned int（un），而它是用于描述这个类的年龄（Age）属性的。

> 小知识：为什么小数在 C++中被称为浮点数？
>
> 比如，我们要在Ｃ++中表达这样两个小数：
>
> 100000000000.0
>
> 0.000000000001
>
> 如果采用定点（小数点固定）的表达方式，我们需要保存成如下的形式：
>
> 100000000000.000000000000
>
> 000000000000.000000000001
>
> 采用这种方式，浪费了宝贵的存储资源。为了解决这个问题，C++采用了一种新的保存方式：将数字表示成指数形式，保存每个数字的有效数字和指数。按照这种方式，上面的两个数可以保存成如下的形式：
>
> 小数 1 指数 11（小数点往左移动了 11 位）
>
> 小数 1 指数 -12（小数点往右移动了 12 位）
>
> 因为这种表达方式中的小数点是浮动（float）的，所以小数也被称为浮点数。 

## 结构体

定义：

```c++
// 定义结构体 Human 描述人这个复杂事物
struct Human
{
 string m_strName; // 姓名
 bool m_bMale; // 性别
 int m_nAge; // 年龄
};
```

使用：

```c++
// 定义一个 Human 类型变量 chenlq，
// 用来描述人这个复杂事物
Human chenlq;
// 这个人的姓名是“陈良乔”
chenlq.m_strName = "陈良乔"; 
// 年龄 23 岁
chenlq.m_nAge = 33;
```

# 第五章 用函数封装程序功能

## 用 const 对参数进行修饰，防止参数被意外修改

```c++
// 用 const 关键字保护参数值不被修改
int Add(const int a, const int b)
{
// 错误：尝试修改使用 const 修饰的参数
a = 1982;
b = 1003;
return a + b;
}
```

## 用空间换时间的内联函数

*函数有一个潜在的缺点：调用函数比求解等价表达式要慢得多。*C++中支持**内联函数**，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义的前面即可将函数指定为内联函数。

当编译器编译程序时，如果发现某段代码调用的是一个内联函数，那么它就不再去调用该函数，而是**将该函数的代码直接插入当前函数调用的位置**，这样就省去了函数调用过程中的那些繁琐的幕后工作.

> 举个栗子：假设我们将 max 定义为内联函数：
>
> ```c++
> inline int max(int a, int b)
> {
>  return a > b ? a : b;
> }
> ```
>
> 调用： `cout<<max(a, b)<<endl`;
>
> 在编译时展开为： `cout<<(a > b ? a : b)<<endl`，从而消除了把 max写成函数的额外执行开销

------

注意：内联函数虽然可以节约时间，但是将导致整个程序体积的增大。使用时最好遵循一下规则：

- 内联函数要短小精悍
- 内联函数执行的时间要短
- 内联函数应该是被重复多次调用的

## 重载函数

所谓重载（overload）函数，因为实现的功能相似，所以将多个函数取相同的函数名，但是参数的个数或类型不同，就构成了函数重载，而这两个函数就被称为重载函数。

经过函数重载，编译器会根据实际调用函数时不同的参数类型和个数调用与之匹配的重载函数，这样虽然我们在代码形式上调用的都是同一个函数，可实际最终调用的却是重载函数的不同版本。

代码例子：

结果：

int Add( int a, int b )被调用！

2 + 3 = 5

double Add( double a, double b )被调用！

2.5 + 10.3 = 12.8
